Index: squid/src/cf.data.pre
diff -c squid/src/cf.data.pre:1.245.2.42 squid/src/cf.data.pre:1.245.2.43
*** squid/src/cf.data.pre:1.245.2.42	Sun May 18 15:49:19 2003
--- squid/src/cf.data.pre	Wed May 21 08:34:38 2003
***************
*** 2612,2617 ****
--- 2612,2618 ----
  DEFAULT: none
  DOC_START
  	Usage:   deny_info err_page_name acl
+ 	or       deny_info http://... acl
  	Example: deny_info ERR_CUSTOM_ACCESS_DENIED bad_guys
  
  	This can be used to return a ERR_ page for requests which
***************
*** 2621,2626 ****
--- 2622,2631 ----
  
  	You may use ERR_ pages that come with Squid or create your own pages
  	and put them into the configured errors/ directory.
+ 
+ 	Alternatively you can specify an error URL. The browsers will then
+ 	get redirected (302) to the specified URL. %s in the redirection
+ 	URL will be replaced by the requested URL.
  
  	Alternatively you can tell Squid to reset the TCP connection
  	by specifying TCP_RESET.
Index: squid/src/errorpage.c
diff -c squid/src/errorpage.c:1.167.2.6 squid/src/errorpage.c:1.167.2.7
*** squid/src/errorpage.c:1.167.2.6	Fri Sep 20 04:28:53 2002
--- squid/src/errorpage.c	Wed May 21 08:34:38 2003
***************
*** 121,129 ****
  	    /* dynamic */
  	    ErrorDynamicPageInfo *info = ErrorDynamicPages.items[i - ERR_MAX];
  	    assert(info && info->id == i && info->page_name);
! 	    error_text[i] = errorLoadText(info->page_name);
  	}
- 	assert(error_text[i]);
      }
  }
  
--- 121,131 ----
  	    /* dynamic */
  	    ErrorDynamicPageInfo *info = ErrorDynamicPages.items[i - ERR_MAX];
  	    assert(info && info->id == i && info->page_name);
! 	    if (strchr(info->page_name, ':') == NULL) {
! 		/* Not on redirected errors... */
! 		error_text[i] = errorLoadText(info->page_name);
! 	    }
  	}
      }
  }
  
***************
*** 212,224 ****
      xfree(info);
  }
  
  int
  errorReservePageId(const char *page_name)
  {
!     ErrorDynamicPageInfo *info =
!     errorDynamicPageInfoCreate(ERR_MAX + ErrorDynamicPages.count, page_name);
!     stackPush(&ErrorDynamicPages, info);
!     return info->id;
  }
  
  static const char *
--- 214,245 ----
      xfree(info);
  }
  
+ static int
+ errorPageId(const char *page_name)
+ {
+     int i;
+     for (i = 0; i < ERR_MAX; i++) {
+ 	if (strcmp(err_type_str[i], page_name) == 0)
+ 	    return i;
+     }
+     for (i = 0; i < ErrorDynamicPages.count; i++) {
+ 	if (strcmp(((ErrorDynamicPageInfo *) ErrorDynamicPages.items[i - ERR_MAX])->page_name, page_name) == 0)
+ 	    return i + ERR_MAX;
+     }
+     return ERR_NONE;
+ }
+ 
  int
  errorReservePageId(const char *page_name)
  {
!     ErrorDynamicPageInfo *info;
!     int id = errorPageId(page_name);
!     if (id == ERR_NONE) {
! 	info = errorDynamicPageInfoCreate(ERR_MAX + ErrorDynamicPages.count, page_name);
! 	stackPush(&ErrorDynamicPages, info);
! 	id = info->id;
!     }
!     return id;
  }
  
  static const char *
***************
*** 579,601 ****
  errorBuildReply(ErrorState * err)
  {
      HttpReply *rep = httpReplyCreate();
!     MemBuf content = errorBuildContent(err);
      http_version_t version;
      /* no LMT for error pages; error pages expire immediately */
      httpBuildVersion(&version, 1, 0);
!     httpReplySetHeaders(rep, version, err->http_status, NULL, "text/html", content.size, 0, squid_curtime);
!     /*
!      * include some information for downstream caches. Implicit
!      * replaceable content. This isn't quite sufficient. xerrno is not
!      * necessarily meaningful to another system, so we really should
!      * expand it. Additionally, we should identify ourselves. Someone
!      * might want to know. Someone _will_ want to know OTOH, the first
!      * X-CACHE-MISS entry should tell us who.
!      */
!     httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%s %d",
! 	errorPageName(err->page_id), err->xerrno);
!     httpBodySet(&rep->body, &content);
!     /* do not memBufClean() the content, it was absorbed by httpBody */
      return rep;
  }
  
--- 600,631 ----
  errorBuildReply(ErrorState * err)
  {
      HttpReply *rep = httpReplyCreate();
!     const char *name = errorPageName(err->page_id);
      http_version_t version;
      /* no LMT for error pages; error pages expire immediately */
      httpBuildVersion(&version, 1, 0);
!     if (strchr(name, ':')) {
! 	/* Redirection */
! 	char *quoted_url = rfc1738_escape_part(errorConvert('u', err));
! 	httpReplySetHeaders(rep, version, HTTP_MOVED_TEMPORARILY, NULL, "text/html", 0, 0, squid_curtime);
! 	httpHeaderPutStrf(&rep->header, HDR_LOCATION, name, quoted_url);
! 	httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%d %s\n", err->http_status, "Access Denied");
!     } else {
! 	MemBuf content = errorBuildContent(err);
! 	httpReplySetHeaders(rep, version, err->http_status, NULL, "text/html", content.size, 0, squid_curtime);
! 	/*
! 	 * include some information for downstream caches. Implicit
! 	 * replaceable content. This isn't quite sufficient. xerrno is not
! 	 * necessarily meaningful to another system, so we really should
! 	 * expand it. Additionally, we should identify ourselves. Someone
! 	 * might want to know. Someone _will_ want to know OTOH, the first
! 	 * X-CACHE-MISS entry should tell us who.
! 	 */
! 	httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%s %d",
! 	    name, err->xerrno);
! 	httpBodySet(&rep->body, &content);
! 	/* do not memBufClean() the content, it was absorbed by httpBody */
!     }
      return rep;
  }
  
