Index: squid/src/fs/aufs/aiops.c
diff -c squid/src/fs/aufs/aiops.c:1.12.2.1 squid/src/fs/aufs/aiops.c:1.12.2.2
*** squid/src/fs/aufs/aiops.c:1.12.2.1	Sat Jul 20 18:30:03 2002
--- squid/src/fs/aufs/aiops.c	Sat Nov  9 03:42:36 2002
***************
*** 185,191 ****
      return p;
  }
  
! static void *
  squidaio_xmalloc(int size)
  {
      void *p;
--- 185,191 ----
      return p;
  }
  
! void *
  squidaio_xmalloc(int size)
  {
      void *p;
***************
*** 211,217 ****
      return p;
  }
  
! static void
  squidaio_xfree(void *p, int size)
  {
      MemPool *pool;
--- 211,217 ----
      return p;
  }
  
! void
  squidaio_xfree(void *p, int size)
  {
      MemPool *pool;
***************
*** 523,531 ****
  	squidaio_xstrfree(requestp->path);
  	break;
      case _AIO_OP_READ:
- 	if (!cancelled && requestp->ret > 0)
- 	    xmemcpy(requestp->bufferp, requestp->tmpbufp, requestp->ret);
- 	squidaio_xfree(requestp->tmpbufp, requestp->buflen);
  	break;
      case _AIO_OP_WRITE:
  	squidaio_xfree(requestp->tmpbufp, requestp->buflen);
--- 523,528 ----
***************
*** 596,602 ****
      requestp = memPoolAlloc(squidaio_request_pool);
      requestp->fd = fd;
      requestp->bufferp = bufp;
-     requestp->tmpbufp = (char *) squidaio_xmalloc(bufs);
      requestp->buflen = bufs;
      requestp->offset = offset;
      requestp->whence = whence;
--- 593,598 ----
***************
*** 613,619 ****
  squidaio_do_read(squidaio_request_t * requestp)
  {
      lseek(requestp->fd, requestp->offset, requestp->whence);
!     requestp->ret = read(requestp->fd, requestp->tmpbufp, requestp->buflen);
      requestp->err = errno;
  }
  
--- 609,615 ----
  squidaio_do_read(squidaio_request_t * requestp)
  {
      lseek(requestp->fd, requestp->offset, requestp->whence);
!     requestp->ret = read(requestp->fd, requestp->bufferp, requestp->buflen);
      requestp->err = errno;
  }
  
Index: squid/src/fs/aufs/async_io.c
diff -c squid/src/fs/aufs/async_io.c:1.10.2.2 squid/src/fs/aufs/async_io.c:1.10.2.4
*** squid/src/fs/aufs/async_io.c:1.10.2.2	Fri Aug 23 16:31:53 2002
--- squid/src/fs/aufs/async_io.c	Sun Nov 10 05:06:07 2002
***************
*** 53,58 ****
--- 53,59 ----
      AIOCB *done_handler;
      void *done_handler_data;
      squidaio_result_t result;
+     int len;
      char *bufp;
      FREE *free_func;
      dlink_node node;
***************
*** 147,153 ****
  void
  aioCancel(int fd)
  {
!     squidaio_ctrl_t *curr;
      AIOCB *done_handler;
      void *their_data;
      dlink_node *m, *next;
--- 148,154 ----
  void
  aioCancel(int fd)
  {
!     squidaio_ctrl_t *ctrlp;
      AIOCB *done_handler;
      void *their_data;
      dlink_node *m, *next;
***************
*** 156,178 ****
      squidaio_counts.cancel++;
      for (m = used_list.head; m; m = next) {
  	next = m->next;
! 	curr = m->data;
! 	if (curr->fd != fd)
  	    continue;
  
! 	squidaio_cancel(&curr->result);
  
! 	if ((done_handler = curr->done_handler)) {
! 	    their_data = curr->done_handler_data;
! 	    curr->done_handler = NULL;
! 	    curr->done_handler_data = NULL;
! 	    debug(32, 2) ("this be aioCancel\n");
  	    if (cbdataValid(their_data))
! 		done_handler(fd, their_data, -2, -2);
  	    cbdataUnlock(their_data);
  	}
  	dlinkDelete(m, &used_list);
! 	memPoolFree(squidaio_ctrl_pool, curr);
      }
  }
  
--- 157,185 ----
      squidaio_counts.cancel++;
      for (m = used_list.head; m; m = next) {
  	next = m->next;
! 	ctrlp = m->data;
! 	if (ctrlp->fd != fd)
  	    continue;
  
! 	squidaio_cancel(&ctrlp->result);
  
! 	if ((done_handler = ctrlp->done_handler)) {
! 	    their_data = ctrlp->done_handler_data;
! 	    ctrlp->done_handler = NULL;
! 	    ctrlp->done_handler_data = NULL;
! 	    debug(32, 0) ("this be aioCancel. Danger ahead!\n");
  	    if (cbdataValid(their_data))
! 		done_handler(fd, their_data, NULL, -2, -2);
  	    cbdataUnlock(their_data);
+ 	    /* free data if requested to aioWrite() */
+ 	    if (ctrlp->free_func)
+ 		ctrlp->free_func(ctrlp->bufp);
+ 	    /* free temporary read buffer */
+ 	    if (ctrlp->operation == _AIO_READ)
+ 		squidaio_xfree(ctrlp->bufp, ctrlp->len);
  	}
  	dlinkDelete(m, &used_list);
! 	memPoolFree(squidaio_ctrl_pool, ctrlp);
      }
  }
  
***************
*** 206,212 ****
  
  
  void
! aioRead(int fd, int offset, char *bufp, int len, AIOCB * callback, void *callback_data)
  {
      squidaio_ctrl_t *ctrlp;
      int seekmode;
--- 213,219 ----
  
  
  void
! aioRead(int fd, int offset, int len, AIOCB * callback, void *callback_data)
  {
      squidaio_ctrl_t *ctrlp;
      int seekmode;
***************
*** 218,223 ****
--- 225,232 ----
      ctrlp->done_handler = callback;
      ctrlp->done_handler_data = callback_data;
      ctrlp->operation = _AIO_READ;
+     ctrlp->len = len;
+     ctrlp->bufp = squidaio_xmalloc(len);
      if (offset >= 0)
  	seekmode = SEEK_SET;
      else {
***************
*** 226,232 ****
      }
      cbdataLock(callback_data);
      ctrlp->result.data = ctrlp;
!     squidaio_read(fd, bufp, len, offset, seekmode, &ctrlp->result);
      dlinkAdd(ctrlp, &ctrlp->node, &used_list);
      return;
  }				/* aioRead */
--- 235,241 ----
      }
      cbdataLock(callback_data);
      ctrlp->result.data = ctrlp;
!     squidaio_read(fd, ctrlp->bufp, len, offset, seekmode, &ctrlp->result);
      dlinkAdd(ctrlp, &ctrlp->node, &used_list);
      return;
  }				/* aioRead */
***************
*** 309,322 ****
  	    ctrlp->done_handler_data = NULL;
  	    if (cbdataValid(their_data)) {
  		retval = 1;	/* Return that we've actually done some work */
! 		done_handler(ctrlp->fd, their_data,
  		    ctrlp->result.aio_return, ctrlp->result.aio_errno);
  	    }
  	    cbdataUnlock(their_data);
  	}
  	/* free data if requested to aioWrite() */
  	if (ctrlp->free_func)
  	    ctrlp->free_func(ctrlp->bufp);
  	if (ctrlp->operation == _AIO_CLOSE)
  	    aioFDWasClosed(ctrlp->fd);
  	memPoolFree(squidaio_ctrl_pool, ctrlp);
--- 318,341 ----
  	    ctrlp->done_handler_data = NULL;
  	    if (cbdataValid(their_data)) {
  		retval = 1;	/* Return that we've actually done some work */
! 		done_handler(ctrlp->fd, their_data, ctrlp->bufp,
  		    ctrlp->result.aio_return, ctrlp->result.aio_errno);
+ 	    } else {
+ 		if (ctrlp->operation == _AIO_OPEN) {
+ 		    /* The open operation was aborted.. */
+ 		    int fd = ctrlp->result.aio_return;
+ 		    if (fd >= 0)
+ 			aioClose(fd);
+ 		}
  	    }
  	    cbdataUnlock(their_data);
  	}
  	/* free data if requested to aioWrite() */
  	if (ctrlp->free_func)
  	    ctrlp->free_func(ctrlp->bufp);
+ 	/* free temporary read buffer */
+ 	if (ctrlp->operation == _AIO_READ)
+ 	    squidaio_xfree(ctrlp->bufp, ctrlp->len);
  	if (ctrlp->operation == _AIO_CLOSE)
  	    aioFDWasClosed(ctrlp->fd);
  	memPoolFree(squidaio_ctrl_pool, ctrlp);
Index: squid/src/fs/aufs/store_asyncufs.h
diff -c squid/src/fs/aufs/store_asyncufs.h:1.9 squid/src/fs/aufs/store_asyncufs.h:1.9.2.1
*** squid/src/fs/aufs/store_asyncufs.h:1.9	Fri Aug 24 08:29:35 2001
--- squid/src/fs/aufs/store_asyncufs.h	Sat Nov  9 03:42:36 2002
***************
*** 34,40 ****
  
  typedef struct _squidaio_result_t squidaio_result_t;
  
! typedef void AIOCB(int fd, void *, int aio_return, int aio_errno);
  
  int squidaio_cancel(squidaio_result_t *);
  int squidaio_open(const char *, int, mode_t, squidaio_result_t *);
--- 34,40 ----
  
  typedef struct _squidaio_result_t squidaio_result_t;
  
! typedef void AIOCB(int fd, void *cbdata, const char *buf, int aio_return, int aio_errno);
  
  int squidaio_cancel(squidaio_result_t *);
  int squidaio_open(const char *, int, mode_t, squidaio_result_t *);
***************
*** 49,54 ****
--- 49,56 ----
  int squidaio_operations_pending(void);
  int squidaio_sync(void);
  int squidaio_get_queue_len(void);
+ void *squidaio_xmalloc(int size);
+ void squidaio_xfree(void *p, int size);
  
  void aioInit(void);
  void aioDone(void);
***************
*** 56,62 ****
  void aioOpen(const char *, int, mode_t, AIOCB *, void *);
  void aioClose(int);
  void aioWrite(int, int offset, char *, int size, AIOCB *, void *, FREE *);
! void aioRead(int, int offset, char *, int size, AIOCB *, void *);
  void aioStat(char *, struct stat *, AIOCB *, void *);
  void aioUnlink(const char *, AIOCB *, void *);
  void aioTruncate(const char *, off_t length, AIOCB *, void *);
--- 58,64 ----
  void aioOpen(const char *, int, mode_t, AIOCB *, void *);
  void aioClose(int);
  void aioWrite(int, int offset, char *, int size, AIOCB *, void *, FREE *);
! void aioRead(int, int offset, int size, AIOCB *, void *);
  void aioStat(char *, struct stat *, AIOCB *, void *);
  void aioUnlink(const char *, AIOCB *, void *);
  void aioTruncate(const char *, off_t length, AIOCB *, void *);
***************
*** 83,89 ****
  	unsigned int read_kicking:1;
  	unsigned int inreaddone:1;
      } flags;
!     const char *read_buf;
      link_list *pending_writes;
      link_list *pending_reads;
  };
--- 85,91 ----
  	unsigned int read_kicking:1;
  	unsigned int inreaddone:1;
      } flags;
!     char *read_buf;
      link_list *pending_writes;
      link_list *pending_reads;
  };
Index: squid/src/fs/aufs/store_io_aufs.c
diff -c squid/src/fs/aufs/store_io_aufs.c:1.15.2.5 squid/src/fs/aufs/store_io_aufs.c:1.15.2.9
*** squid/src/fs/aufs/store_io_aufs.c:1.15.2.5	Sun Aug 11 17:14:35 2002
--- squid/src/fs/aufs/store_io_aufs.c	Thu Nov 14 23:33:25 2002
***************
*** 18,24 ****
  #endif
  static void storeAufsIOCallback(storeIOState * sio, int errflag);
  static AIOCB storeAufsOpenDone;
! static int storeAufsSomethingPending(storeIOState *);
  static int storeAufsKickWriteQueue(storeIOState * sio);
  static CBDUNL storeAufsIOFreeEntry;
  
--- 18,24 ----
  #endif
  static void storeAufsIOCallback(storeIOState * sio, int errflag);
  static AIOCB storeAufsOpenDone;
! static int storeAufsNeedCompletetion(storeIOState *);
  static int storeAufsKickWriteQueue(storeIOState * sio);
  static CBDUNL storeAufsIOFreeEntry;
  
***************
*** 141,147 ****
      squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
      debug(79, 3) ("storeAufsClose: dirno %d, fileno %08X, FD %d\n",
  	sio->swap_dirn, sio->swap_filen, aiostate->fd);
!     if (storeAufsSomethingPending(sio)) {
  	aiostate->flags.close_request = 1;
  	return;
      }
--- 141,147 ----
      squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
      debug(79, 3) ("storeAufsClose: dirno %d, fileno %08X, FD %d\n",
  	sio->swap_dirn, sio->swap_filen, aiostate->fd);
!     if (storeAufsNeedCompletetion(sio)) {
  	aiostate->flags.close_request = 1;
  	return;
      }
***************
*** 168,173 ****
--- 168,174 ----
  	q->offset = offset;
  	q->callback = callback;
  	q->callback_data = callback_data;
+ 	cbdataLock(q->callback_data);
  	linklistPush(&(aiostate->pending_reads), q);
  	return;
      }
***************
*** 180,186 ****
      sio->offset = offset;
      aiostate->flags.reading = 1;
  #if ASYNC_READ
!     aioRead(aiostate->fd, offset, buf, size, storeAufsReadDone, sio);
  #else
      file_read(aiostate->fd, buf, size, offset, storeAufsReadDone, sio);
  #endif
--- 181,187 ----
      sio->offset = offset;
      aiostate->flags.reading = 1;
  #if ASYNC_READ
!     aioRead(aiostate->fd, offset, size, storeAufsReadDone, sio);
  #else
      file_read(aiostate->fd, buf, size, offset, storeAufsReadDone, sio);
  #endif
***************
*** 262,274 ****
  	return 0;
      debug(79, 3) ("storeAufsKickReadQueue: reading queued request of %ld bytes\n",
  	(long int) q->size);
!     storeAufsRead(INDEXSD(sio->swap_dirn), sio, q->buf, q->size, q->offset, q->callback, q->callback_data);
      memPoolFree(aufs_qread_pool, q);
      return 1;
  }
  
  static void
! storeAufsOpenDone(int unused, void *my_data, int fd, int errflag)
  {
      storeIOState *sio = my_data;
      squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
--- 263,277 ----
  	return 0;
      debug(79, 3) ("storeAufsKickReadQueue: reading queued request of %ld bytes\n",
  	(long int) q->size);
!     if (cbdataValid(q->callback_data))
! 	storeAufsRead(INDEXSD(sio->swap_dirn), sio, q->buf, q->size, q->offset, q->callback, q->callback_data);
!     cbdataUnlock(q->callback_data);
      memPoolFree(aufs_qread_pool, q);
      return 1;
  }
  
  static void
! storeAufsOpenDone(int unused, void *my_data, const char *unused2, int fd, int errflag)
  {
      storeIOState *sio = my_data;
      squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
***************
*** 289,295 ****
      if (FILE_MODE(sio->mode) == O_WRONLY) {
  	if (storeAufsKickWriteQueue(sio))
  	    return;
!     } else if (FILE_MODE(sio->mode) == O_RDONLY) {
  	if (storeAufsKickReadQueue(sio))
  	    return;
      }
--- 292,298 ----
      if (FILE_MODE(sio->mode) == O_WRONLY) {
  	if (storeAufsKickWriteQueue(sio))
  	    return;
!     } else if ((FILE_MODE(sio->mode) == O_RDONLY) && !aiostate->flags.close_request) {
  	if (storeAufsKickReadQueue(sio))
  	    return;
      }
***************
*** 300,306 ****
  
  #if ASYNC_READ
  static void
! storeAufsReadDone(int fd, void *my_data, int len, int errflag)
  #else
  static void
  storeAufsReadDone(int fd, const char *buf, int len, int errflag, void *my_data)
--- 303,309 ----
  
  #if ASYNC_READ
  static void
! storeAufsReadDone(int fd, void *my_data, const char *buf, int len, int errflag)
  #else
  static void
  storeAufsReadDone(int fd, const char *buf, int len, int errflag, void *my_data)
***************
*** 311,316 ****
--- 314,320 ----
      STRCB *callback = sio->read.callback;
      void *their_data = sio->read.callback_data;
      ssize_t rlen;
+     int inreaddone = aiostate->flags.inreaddone;	/* Protect from callback loops */
      debug(79, 3) ("storeAufsReadDone: dirno %d, fileno %08X, FD %d, len %d\n",
  	sio->swap_dirn, sio->swap_filen, fd, len);
      aiostate->flags.inreaddone = 1;
***************
*** 337,347 ****
      assert(their_data);
      sio->read.callback = NULL;
      sio->read.callback_data = NULL;
!     if (cbdataValid(their_data))
  	callback(their_data, aiostate->read_buf, rlen);
      cbdataUnlock(their_data);
      aiostate->flags.inreaddone = 0;
!     if (aiostate->flags.close_request)
  	storeAufsIOCallback(sio, errflag);
  }
  
--- 341,356 ----
      assert(their_data);
      sio->read.callback = NULL;
      sio->read.callback_data = NULL;
!     if (!aiostate->flags.close_request && cbdataValid(their_data)) {
! #if ASYNC_READ
! 	if (rlen > 0)
! 	    memcpy(aiostate->read_buf, buf, rlen);
! #endif
  	callback(their_data, aiostate->read_buf, rlen);
+     }
      cbdataUnlock(their_data);
      aiostate->flags.inreaddone = 0;
!     if (aiostate->flags.close_request && !inreaddone)
  	storeAufsIOCallback(sio, errflag);
  }
  
***************
*** 403,438 ****
      debug(79, 3) ("storeAufsIOCallback: errflag=%d\n", errflag);
      sio->callback = NULL;
      sio->callback_data = NULL;
!     debug(79, 3) ("%s:%d\n", __FILE__, __LINE__);
      if (callback)
  	if (NULL == their_data || cbdataValid(their_data))
  	    callback(their_data, errflag, sio);
!     debug(79, 3) ("%s:%d\n", __FILE__, __LINE__);
      cbdataUnlock(their_data);
      aiostate->fd = -1;
      cbdataFree(sio);
      if (fd < 0)
  	return;
!     debug(79, 3) ("%s:%d\n", __FILE__, __LINE__);
      aioClose(fd);
      fd_close(fd);
      store_open_disk_fd--;
!     debug(79, 3) ("%s:%d\n", __FILE__, __LINE__);
  }
  
  
  static int
! storeAufsSomethingPending(storeIOState * sio)
  {
      squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
!     if (aiostate->flags.reading)
! 	return 1;
      if (aiostate->flags.writing)
  	return 1;
!     if (aiostate->flags.opening)
  	return 1;
      if (aiostate->flags.inreaddone)
  	return 1;
      return 0;
  }
  
--- 412,451 ----
      debug(79, 3) ("storeAufsIOCallback: errflag=%d\n", errflag);
      sio->callback = NULL;
      sio->callback_data = NULL;
!     debug(79, 9) ("%s:%d\n", __FILE__, __LINE__);
      if (callback)
  	if (NULL == their_data || cbdataValid(their_data))
  	    callback(their_data, errflag, sio);
!     debug(79, 9) ("%s:%d\n", __FILE__, __LINE__);
      cbdataUnlock(their_data);
      aiostate->fd = -1;
      cbdataFree(sio);
+     if (aiostate->flags.opening)
+ 	Opening_FD--;
      if (fd < 0)
  	return;
!     debug(79, 9) ("%s:%d\n", __FILE__, __LINE__);
      aioClose(fd);
      fd_close(fd);
      store_open_disk_fd--;
!     debug(79, 9) ("%s:%d\n", __FILE__, __LINE__);
  }
  
  
  static int
! storeAufsNeedCompletetion(storeIOState * sio)
  {
      squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
! 
      if (aiostate->flags.writing)
  	return 1;
!     if (aiostate->flags.opening && FILE_MODE(sio->mode) == O_WRONLY)
! 	return 1;
!     if (aiostate->flags.reading)
  	return 1;
      if (aiostate->flags.inreaddone)
  	return 1;
+ 
      return 0;
  }
  
***************
*** 443,449 ****
   * to bother with that.
   */
  static void
! storeAufsIOFreeEntry(void *sio)
  {
!     memPoolFree(squidaio_state_pool, ((storeIOState *) sio)->fsstate);
  }
--- 456,479 ----
   * to bother with that.
   */
  static void
! storeAufsIOFreeEntry(void *siop)
  {
!     storeIOState *sio = (storeIOState *) siop;
!     squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
!     struct _queued_write *qw;
!     struct _queued_read *qr;
!     while ((qw = linklistShift(&aiostate->pending_writes))) {
! 	if (qw->free_func)
! 	    qw->free_func(qw->buf);
! 	memPoolFree(aufs_qwrite_pool, qw);
!     }
!     while ((qr = linklistShift(&aiostate->pending_reads))) {
! 	cbdataUnlock(qr->callback_data);
! 	memPoolFree(aufs_qread_pool, qr);
!     }
!     if (sio->read.callback_data)
! 	cbdataUnlock(sio->read.callback_data);
!     if (sio->callback_data)
! 	cbdataUnlock(sio->callback_data);
!     memPoolFree(squidaio_state_pool, aiostate);
  }
