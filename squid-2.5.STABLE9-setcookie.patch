Index: squid/src/client_side.c
diff -c squid/src/client_side.c:1.561.2.71 squid/src/client_side.c:1.561.2.72
*** squid/src/client_side.c:1.561.2.71	Sun Feb 20 12:07:45 2005
--- squid/src/client_side.c	Wed Mar  2 19:18:29 2005
***************
*** 572,577 ****
--- 572,578 ----
  	}
      } else {
  	/* the client can handle this reply, whatever it is */
+ 	http->flags.hit = 0;
  	http->log_type = LOG_TCP_REFRESH_MISS;
  	if (HTTP_NOT_MODIFIED == mem->reply->sline.status) {
  	    httpReplyUpdateOnNotModified(http->old_entry->mem_obj->reply,
***************
*** 1265,1271 ****
      HttpHeader *hdr = rep ? &rep->header : 0;
      const char *range_err = NULL;
      request_t *request = http->request;
-     int is_hit = isTcpHit(http->log_type);
      assert(request->range);
      /* check if we still want to do ranges */
      if (!rep)
--- 1266,1271 ----
***************
*** 1286,1292 ****
  	range_err = "too complex range header";
      else if (!request->flags.cachable)	/* from we_do_ranges in http.c */
  	range_err = "non-cachable request";
!     else if (!is_hit && httpHdrRangeOffsetLimit(http->request->range))
  	range_err = "range outside range_offset_limit";
      /* get rid of our range specs on error */
      if (range_err) {
--- 1286,1292 ----
  	range_err = "too complex range header";
      else if (!request->flags.cachable)	/* from we_do_ranges in http.c */
  	range_err = "non-cachable request";
!     else if (!http->flags.hit && httpHdrRangeOffsetLimit(http->request->range))
  	range_err = "range outside range_offset_limit";
      /* get rid of our range specs on error */
      if (range_err) {
***************
*** 1343,1349 ****
  clientBuildReplyHeader(clientHttpRequest * http, HttpReply * rep)
  {
      HttpHeader *hdr = &rep->header;
-     int is_hit = isTcpHit(http->log_type);
      request_t *request = http->request;
  #if DONT_FILTER_THESE
      /* but you might want to if you run Squid as an HTTP accelerator */
--- 1343,1348 ----
***************
*** 1354,1360 ****
      /* here: Keep-Alive is a field-name, not a connection directive! */
      httpHeaderDelByName(hdr, "Keep-Alive");
      /* remove Set-Cookie if a hit */
!     if (is_hit)
  	httpHeaderDelById(hdr, HDR_SET_COOKIE);
      /* handle Connection header */
      if (httpHeaderHas(hdr, HDR_CONNECTION)) {
--- 1353,1359 ----
      /* here: Keep-Alive is a field-name, not a connection directive! */
      httpHeaderDelByName(hdr, "Keep-Alive");
      /* remove Set-Cookie if a hit */
!     if (http->flags.hit)
  	httpHeaderDelById(hdr, HDR_SET_COOKIE);
      /* handle Connection header */
      if (httpHeaderHas(hdr, HDR_CONNECTION)) {
***************
*** 1383,1389 ****
      /*
       * Add a estimated Age header on cache hits.
       */
!     if (is_hit) {
  	/*
  	 * Remove any existing Age header sent by upstream caches
  	 * (note that the existing header is passed along unmodified
--- 1382,1388 ----
      /*
       * Add a estimated Age header on cache hits.
       */
!     if (http->flags.hit) {
  	/*
  	 * Remove any existing Age header sent by upstream caches
  	 * (note that the existing header is passed along unmodified
***************
*** 1431,1437 ****
  	authenticateFixHeader(rep, request->auth_user_request, request, http->flags.accel, 0);
      /* Append X-Cache */
      httpHeaderPutStrf(hdr, HDR_X_CACHE, "%s from %s",
! 	is_hit ? "HIT" : "MISS", getMyHostname());
  #if USE_CACHE_DIGESTS
      /* Append X-Cache-Lookup: -- temporary hack, to be removed @?@ @?@ */
      httpHeaderPutStrf(hdr, HDR_X_CACHE_LOOKUP, "%s from %s:%d",
--- 1430,1436 ----
  	authenticateFixHeader(rep, request->auth_user_request, request, http->flags.accel, 0);
      /* Append X-Cache */
      httpHeaderPutStrf(hdr, HDR_X_CACHE, "%s from %s",
! 	http->flags.hit ? "HIT" : "MISS", getMyHostname());
  #if USE_CACHE_DIGESTS
      /* Append X-Cache-Lookup: -- temporary hack, to be removed @?@ @?@ */
      httpHeaderPutStrf(hdr, HDR_X_CACHE_LOOKUP, "%s from %s:%d",
***************
*** 1505,1510 ****
--- 1504,1510 ----
      MemObject *mem;
      request_t *r = http->request;
      debug(33, 3) ("clientCacheHit: %s, %d bytes\n", http->uri, (int) size);
+     http->flags.hit = 0;
      if (http->entry == NULL) {
  	memFree(buf, MEM_CLIENT_SOCK_BUF);
  	debug(33, 3) ("clientCacheHit: request aborted\n");
***************
*** 1592,1597 ****
--- 1592,1598 ----
  	clientPurgeRequest(http);
  	return;
      }
+     http->flags.hit = 1;
      if (checkNegativeHit(e)) {
  	http->log_type = LOG_TCP_NEGATIVE_HIT;
  	clientSendMoreData(data, buf, size);
***************
*** 2276,2281 ****
--- 2277,2283 ----
      char *url = http->uri;
      request_t *r = http->request;
      ErrorState *err = NULL;
+     http->flags.hit = 0;
      debug(33, 4) ("clientProcessOnlyIfCachedMiss: '%s %s'\n",
  	RequestMethodStr[r->method], url);
      http->al.http.code = HTTP_GATEWAY_TIMEOUT;
Index: squid/src/structs.h
diff -c squid/src/structs.h:1.408.2.37 squid/src/structs.h:1.408.2.38
*** squid/src/structs.h:1.408.2.37	Tue Feb 22 17:06:35 2005
--- squid/src/structs.h	Wed Mar  2 19:18:29 2005
***************
*** 1099,1104 ****
--- 1099,1105 ----
  	unsigned int internal:1;
  	unsigned int done_copying:1;
  	unsigned int purging:1;
+ 	unsigned int hit:1;
      } flags;
      struct {
  	http_status status;
