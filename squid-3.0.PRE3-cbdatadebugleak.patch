Index: squid3/src/cbdata.cc
diff -c squid3/src/cbdata.cc:1.59 squid3/src/cbdata.cc:1.60
*** squid3/src/cbdata.cc:1.59	Wed Jul 16 01:18:16 2003
--- squid3/src/cbdata.cc	Mon Sep  1 17:41:17 2003
***************
*** 83,92 ****
      void dump(StoreEntry *)const;
  #endif
  
!     void deleteSelf();
      int valid;
      int locks;
!     int type;
  #if CBDATA_DEBUG
  
      void addHistory(char const *label, char const *file, int line)
--- 83,95 ----
      void dump(StoreEntry *)const;
  #endif
  
!     void *operator new(size_t size, void *where);
!     void operator delete(void *where, void *where);
! 
!     ~cbdata();
      int valid;
      int locks;
!     cbdata_type type;
  #if CBDATA_DEBUG
  
      void addHistory(char const *label, char const *file, int line)
***************
*** 106,111 ****
--- 109,116 ----
      /* cookie used while debugging */
      long cookie;
      /* MUST be the last per-instance member */
+     /* TODO: examine making cbdata templated on this - so we get type
+      * safe access to data - RBC 20030902 */
      void *data;
  void check() const { assert(cookie == ((long)this ^ Cookie));}
  
***************
*** 119,124 ****
--- 124,145 ----
  const long cbdata::Cookie((long)0xDEADBEEF);
  const long cbdata::Offset(MakeOffset());
  
+ void *
+ cbdata::operator new(size_t size, void *where)
+ {
+     // assert (size == sizeof(cbdata));
+     return where;
+ }
+ 
+ void
+ cbdata::operator delete(void *where, void *where2)
+ {
+     /* Only ever invoked when placement new throws
+      * an exception. Used to prevent an incorrect
+      * free.
+      */
+ }
+ 
  long
  cbdata::MakeOffset()
  {
***************
*** 141,148 ****
  *cbdata_index = NULL;
  int cbdata_types = 0;
  
! void
! cbdata::deleteSelf()
  {
  #if CBDATA_DEBUG
      CBDataCall *aCall;
--- 162,168 ----
  *cbdata_index = NULL;
  int cbdata_types = 0;
  
! cbdata::~cbdata()
  {
  #if CBDATA_DEBUG
      CBDataCall *aCall;
***************
*** 156,163 ****
  
      if (free_func)
          free_func(&data);
- 
-     memPoolFree(cbdata_index[type].pool, this);
  }
  
  static void
--- 176,181 ----
***************
*** 240,246 ****
  {
      cbdata *p;
      assert(type > 0 && type < cbdata_types);
!     p = (cbdata *)memPoolAlloc(cbdata_index[type].pool);
      p->type = type;
      p->valid = 1;
      p->locks = 0;
--- 258,266 ----
  {
      cbdata *p;
      assert(type > 0 && type < cbdata_types);
!     p = new (memPoolAlloc(cbdata_index[type].pool)) cbdata;
!     //    p = (cbdata *)memPoolAlloc(cbdata_index[type].pool);
! 
      p->type = type;
      p->valid = 1;
      p->locks = 0;
***************
*** 297,303 ****
      dlinkDelete(&c->link, &cbdataEntries);
  #endif
  
!     c->deleteSelf();
      return NULL;
  }
  
--- 317,336 ----
      dlinkDelete(&c->link, &cbdataEntries);
  #endif
  
!     cbdata_type theType = c->type;
!     c->cbdata::~cbdata();
! 
!     /* This is ugly. But: operator delete doesn't get
!      * the type parameter, so we can't use that 
!      * to free the memory.
!      * So, we free it ourselves.
!      * Note that this means a non-placement 
!      * new would be a seriously bad idea.
!      * Lastly, if we where a templated class,
!      * we could use the normal delete operator
!      * and it would Just Work. RBC 20030902
!      */
!     memPoolFree(cbdata_index[theType].pool, c);
      return NULL;
  }
  
***************
*** 381,387 ****
  
  #endif
  
!     c->deleteSelf();
  }
  
  int
--- 414,434 ----
  
  #endif
  
!     cbdata_type theType = c->type;
! 
!     c->cbdata::~cbdata();
! 
!     /* This is ugly. But: operator delete doesn't get
!      * the type parameter, so we can't use that 
!      * to free the memory.
!      * So, we free it ourselves.
!      * Note that this means a non-placement 
!      * new would be a seriously bad idea.
!      * Lastly, if we where a templated class,
!      * we could use the normal delete operator
!      * and it would Just Work. RBC 20030902
!      */
!     memPoolFree(cbdata_index[theType].pool, c);
  }
  
  int
